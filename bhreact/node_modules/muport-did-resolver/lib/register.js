'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var fetchMuPortDoc = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(ipfsHash, ipfsConf) {
    var doc;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            doc = void 0;
            _context2.prev = 1;
            _context2.next = 4;
            return (0, _lookup.ipfsLookup)(ipfsHash, ipfsConf);

          case 4:
            doc = _context2.sent;
            _context2.next = 9;
            break;

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2['catch'](1);

          case 9:
            if (!(!doc || !doc.signingKey)) {
              _context2.next = 11;
              break;
            }

            throw new Error('Invalid muport did');

          case 11:
            return _context2.abrupt('return', doc);

          case 12:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this, [[1, 7]]);
  }));

  return function fetchMuPortDoc(_x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}();

var _didResolver = require('did-resolver');

var _lookup = require('./lookup');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function register() {
  var resolve = function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(did, parsed) {
      var doc, newHash;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetchMuPortDoc(parsed.id, opts.ipfsConf);

            case 2:
              doc = _context.sent;
              _context.next = 5;
              return (0, _lookup.ethLookup)(doc.managementKey, opts.rpcProviderUrl);

            case 5:
              newHash = _context.sent;

              if (!newHash) {
                _context.next = 10;
                break;
              }

              _context.next = 9;
              return fetchMuPortDoc(newHash, opts.ipfsConf);

            case 9:
              doc = _context.sent;

            case 10:
              return _context.abrupt('return', wrapDocument(did, doc));

            case 11:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function resolve(_x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();

  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _didResolver.registerMethod)('muport', resolve);
}

function wrapDocument(did, muportDocument) {
  if (muportDocument.version !== 1) throw new Error('Unsupported muportDocument version');
  var doc = {
    "@context": "https://w3id.org/did/v1",
    "id": did,
    "publicKey": [{
      "id": did + "#signingKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did,
      "publicKeyHex": muportDocument.signingKey
    }, {
      "id": did + "#managementKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did
    }, {
      "id": did + "#encryptionKey",
      "type": "Curve25519EncryptionPublicKey",
      "owner": did,
      "publicKeyBase64": muportDocument.asymEncryptionKey
    }],
    "authentication": [{
      "type": "Secp256k1SignatureAuthentication2018",
      "publicKey": did + "#signingKey"
    }],
    "muportData": {}
  };
  if (muportDocument.managementKey.length === 42) {
    doc.publicKey[1].ethereumAddress = muportDocument.managementKey;
  } else {
    doc.publicKey[1].publicKeyHex = muportDocument.managementKey;
  }
  if (muportDocument.publicProfile) doc.uportProfile = muportDocument.publicProfile;
  if (muportDocument.symEncryptedData) doc.muportData.symEncryptedData = muportDocument.symEncryptedData;
  if (muportDocument.recoveryNetwork) doc.muportData.recoveryNetwork = muportDocument.recoveryNetwork;
  return doc;
}

module.exports = register;